# Insiderr REST API

<!--
FIXME: This should be autogenerated from the code
-->

# General
For all actions following authentication, the session token is always included
in the Authorization header.

All data is returns in JSON format.

# Authentication

## Create new user

    POST /register/

### Post Body

    {"pub_key": <key>} 

### Reply

    {"ok": true, "key": <key>}

## Login / get session token
    
    POST /login/

### Post Body

    {"key": <key>}

### Reply

    {"ok": true, "token": <token>}

# Channels

## Data format

    channel = {
        key
        title
    }

## Get a list of channels

    GET /channels

### Reply

    [{"key" : <key>, "title": <title>}, ...]

Returns a list of channel data

## Get items feed for a channel

    GET /channel/{key}/?hash=<hash>&count=<count>[&stats_only=true]


### Reply

   [{"post": <post>, "hash": <hash>} ...]>

Returns a list of {count} items posted starting from {hash} (or from the hash
representing the current query, if {hash} is not provided). {count} may be
negative, indicating that items posted before {hash} should be returned. Each
item in the list is accompanied by a hash, allowing it to be the base hash for
the next query (according to clients requirements).

# Posts
We currently call a new thing user submits a Post until we find a better name.

## Create

    POST /posts/

### Post Body

    {
        "title": <title>,
        "content": <content>,
        "theme": <theme>,
        "background": <background>,
        "channels": [<channel>, ...],
    }

### Reply

    { ok: true, key: <key>,}

## Get

    GET /posts/<key>?fields=field1,field2...

### Reply

    { "ok": true,
        "post": {
            "key": <key>,
            "content": <content>,
            "theme": <theme>,
            "background": <background>,
            "channels": [<channel>, ...],
            "comment_count": <count>,
            "upvote_count": <count>,
            "downvote_count": <count>
        }
    }

# Comments

## Create

    POST /comments/<post_key>

### Post Body

    {
         "content": <content>
    }

### Reply

    {
        "ok": true,
        "key": <key>,
        "icon": <icon key>
    }

## Get a single comment

    GET /comments/<key>

### Reply

    {
        "ok": true,
        "key": <key>,
        "content": <content>,
        "icon": <icon key>,
        "upvote_count": <count>,
        "downvote_count": <count>
    }


## Get Comments for a Post

    GET /comments/<post_key>

### Reply
    {
        "ok": true,
        "hash": <hash>,
        "comments": [<comment_body>, ]
    }


# Voting
Vote an item/comment up or down

    POST /votes/<key>/up
    POST /votes/<key>/down


## Reply

    {
        "ok": true,
        "key": <key>,
        "upvote_count": <count>,
        "downvote_count": <count>
    }    

# Updates
Get updates for list of keys (multiple HTTP parameters).

    GET /updates/?since=<since>&key=<key1>&key=<key2>...

## Reply

    {
        "ok": true,
        "updates": <updates>
    }

Update will be a hash of

    {"obj": <object>, "hash": <hash>}

Objects with do not have an update.created >= <since> will be omitted from the
reply.

# Items
Batch get a list of items from the database for list of keys (multiple HTTP
parameters).

    GET /items/?key=<key1>&key=<key2>...

## Reply

    {
        "ok": true,
        "objects": [<obj1>, <obj2> ...]
    }


# Flag

Flag Post/Comment as inappropriate (will email admin)

    POST /flag/<key>

## Reply

    {"ok": true}

## Feedback

Send feedback to server (will email admin)

    POST /feedback/

Message in post body.

## Reply

    {"ok": true, "key": <key>}

# Icons
Get icons JSON data

    GET /icons
